
首先：获取数据、绑定数据、焦点、各个按钮，这四个需要写出来！！！
特别是要注意，使用bindinglist和list的区别；
或者new的时候，不会对所有的属性赋值，只有在保存的时候判断，那个时候赋值？
new的时候只添加编号、创建时间等等字段，名称、内容等字段在编辑的时候补充



1. 页面调整+事件的新增+数据添加状态
treeView1.SelectedNode.Remove();
binginglist

projTree1.theTreeList.GetDataRecordByNode(TreeListNode node) as SPI 
gridview是getrow  as  spi

对象是类的特定实例？

页面布局：
我今天才想明白：：：
属性、关系是人为定义的，对象是录入的！！！
只有录入的需要实时填写卡片。定义的只要定义成型之后，就不需要实时定制了！！！
设计的几个思路转变：
1. 所有的模块分离，拆分成一个一个的小卡片，每个界面录入一种信息
2. 所有的模块合成，录入、定义、显示都放在一个界面上
3. 属性、关系是定义，对象是录入
思路的转变：
1-2：模块太分散，操作不够集中，数据展现太过分离，没有流畅的操作
2-3：合成之后的界面太过庞大，数据展示仍然有些不流畅，步骤操作繁琐，变更思想：定义和录入的区别

一个对象对应



事件 | 句子 | 词汇 | 定义卡片 | 属性 | 关系 | TAB：右对象及右属性
（右属性已有的为红色，没有的是灰色，如果勾选的是灰色，则自动给那个对象添加一条属性）

事件、句子、词汇是冻结页面！！！
后面是可以用滚动条的
定义卡片也可以定义属性和关系！！！做法同对象！！！
记住：：由于页面的所有数据永远和list一样，所以保存之后，不需要进行任何刷新操作
只需要修改list中所有行为s状态即可（这样就可以保持和重新获取一致）很好的思想，哈哈哈哈哈！！！
同时记住！！！
右边的数据，必定是根据左边来的



1 事件：：事件：如果事件记忆不清楚或者事件记忆错误，使用编辑修改，并修改句子。
如果是后续事件发展：新建新的事件，或在后续添加
2 句子
3 词汇
4 属性
5 关系
6 TAB及对应属性
7 

找个时间，把对象属性和属性对象这两种对象分辨开来啊！！！不然太混乱了

2. 页面功能

总体思想：：全局属性永远是最新的，同时全局属性上都有相关的状态，
后台根据具体数据状态判断如何处理数据
所有只有两个工作会操作数据库：获取+保存

分页功能：：：：
由于需要分页功能，所以思考是不是把事件树改成事件列表；
然后我发现！！！！！！！！！！！！！！！！！！！！！！
貌似。。。。事件不应该用树而应该用列表，因为，所有的属性都是由属性树和关系树关联的，
自己不能自带属性哦！！
现在改为：：句子、词汇 ：：： 都有插入功能，目的是当事件中间修改的时候，
可以添加新句子、新词汇

全局属性：

事件list 
事件info
句子list
句子info
词汇list
词汇info
属性list
属性info

关系list
关系info

关系datalist

标志：

db：N E S
lobject：e s v
robject：e s v
c ： color

特殊变量：
eventclient
sentenceclient
vocabularyclient
propertyclient
relationclient

要求：无论什么情况都可以
1.	每行数据都加上状态字段：新增，编辑，保存，作废，不同的字段在保存的时候有不同的作用
2.	添加删除功能？
3.	日志在代码库里写
4.	代码改为core
6.	属性和对象分离，因为不是一个维度的，分开操作，还是之前的界面那种形式吧，
属性，右属性，中间是关系
7.	明天把前台代码改好，不能墨迹了
8. 保存按钮在定义卡片上，对象卡片只能有新增、作废、编辑按钮（作废是双向的，
当前是作废状态就会变换成非作废状态）
9. 一旦行上有状态了！！！那么

总：
获取数据：：
所有作废数据默认为灰色



事件：：：

焦点触发 
1. 更新对象
2. 刷新其他页面

新增 

1. 新增对象，并add到list中
2. 清空其他页面
2. 放开定义限制
3. 刷新tab页
4. 修改flag

新增下级 ： 调用新增，在新增对象时判断是否为新增下级，做一些级次上的修改

编辑 : 

1. 编辑对象
2. 放开定义限制
2. 修改flag


作废：

1. 编辑对象，反向作废
2. 修改flag

句子
焦点触发 
1. 更新对象
2. 刷新其他页面

新增
1. 新增对象，并add到list中
2. 清空其他页面
2. 放开定义限制
3. 刷新tab页
4. 修改flag

编辑

1. 编辑对象
2. 放开定义限制
2. 修改flag

作废
1. 编辑对象，反向作废
2. 修改flag

词汇
焦点触发 
1. 更新对象
2. 刷新其他页面

新增
1. 新增对象，并add到list中
2. 清空其他页面
2. 放开定义限制
3. 刷新tab页
4. 修改flag

编辑

1. 编辑对象
2. 放开定义限制
2. 修改flag

作废
1. 编辑对象，反向作废
2. 修改flag

定义框
保存：
1. 保存所有对象 并修改状态为s
2. 保存所有属性 并修改状态为s
3. 保存所有关系 并修改状态为s （同时删除所有的只有左属性没有有属性的关系数据）
2. 修改flag


属性树 --自身操作时，会锁定之外所有的页面
焦点触发 
1. 更新对象，且为左侧对象附上这个属性
2. 刷新勾选关系树（同时删除所有的只有左属性没有有属性的垃圾关系数据）以及刷新对应属性
tab页的数据颜色和勾选框

新增 

0. 锁定其他页面
1. 新增对象，并add到list中
2. 放开定义限制
3. 清空关系树勾选框，以及右侧tab页
4. 修改数据flag

编辑 : 

0. 锁定其他页面
1. 编辑对象
2. 放开定义限制
2. 修改flag


作废：

0. 锁定其他页面
1. 编辑对象，反向作废
2. 修改flag

关系树 -- 自身操作时会锁定，其他的所有页面
焦点触发 
1. 更新对象，切位左侧这个对象的这个属性附上这个关系
2. 刷新对应属性tab页的数据颜色和勾选框

新增 

0. 锁定其他页面
1. 新增对象，并add到list中
2. 在左侧页面上全部加上该属性
2. 放开定义限制
3. 清空关系树勾选框，以及右侧tab页
4. 修改数据flag

编辑 : 

0. 锁定其他页面
1. 编辑对象
2. 放开定义限制
2. 修改flag


作废：

0. 锁定其他页面
1. 编辑对象，反向作废
2. 修改flag


TAB及右侧属性

右侧事件、句子、词汇
焦点触发 
1. 更新对象
2. 刷新右侧页面

右侧属性
1.更新对象
2. 只有勾选操作？



新增：：：
一般都是，先新增一条空数据，然后再赋值，这样直观一点
